---
phase: 06-observability-a-testing
plan: 03
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - internal/http/rest/transmission.go
  - internal/http/rest/transmission_test.go
autonomous: true

must_haves:
  truths:
    - "Handler can be tested in isolation without real Put.io API"
    - "Integration tests verify torrent-add with MetaInfo field returns success"
    - "Integration tests verify torrent-add with FileName (magnet) returns success"
    - "Backward compatibility confirmed: magnet links work identically"
    - "Error cases return Transmission-compatible error responses (HTTP 200 with error in result)"
  artifacts:
    - path: "internal/http/rest/transmission.go"
      provides: "DownloadClient interface for mockable client operations"
      contains: "DownloadClient interface"
    - path: "internal/http/rest/transmission_test.go"
      provides: "Integration tests for HTTP handler with mock Put.io client and real torrent fixture support"
      contains: "TestHandleTorrentAdd_RealTorrentFile"
  key_links:
    - from: "internal/http/rest/transmission_test.go"
      to: "internal/http/rest/transmission.go"
      via: "mockPutioClient implementing DownloadClient interface"
      pattern: "mockPutioClient.*DownloadClient"
    - from: "internal/http/rest/transmission_test.go"
      to: "internal/http/rest/transmission.go"
      via: "httptest.ResponseRecorder calling HandleRPC"
      pattern: "httptest.NewRequest.*torrent-add"
---

<objective>
Create integration tests for the Transmission RPC handler covering MetaInfo uploads, magnet link backward compatibility, and error response format.

Purpose: Verify end-to-end handler behavior with mock dependencies, ensuring Sonarr/Radarr webhook payloads are processed correctly.
Output: Integration tests using httptest that verify success and error paths through the full handler stack.
</objective>

<execution_context>
@/Users/italovietro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/italovietro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-observability-a-testing/06-RESEARCH.md
@.planning/phases/06-observability-a-testing/06-01-SUMMARY.md
@internal/http/rest/transmission.go
@internal/http/rest/transmission_test.go
@internal/dc/putio/client.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor TransmissionHandler to use interface and add mock client</name>
  <files>internal/http/rest/transmission.go, internal/http/rest/transmission_test.go</files>
  <action>
**CRITICAL:** The current TransmissionHandler uses `*putio.Client` (concrete type) at line 107 of transmission.go. To enable mocking, we MUST refactor to use an interface.

**Part A: Define interface and refactor handler (transmission.go)**

1. Define a DownloadClient interface in transmission.go (before TransmissionHandler struct):
```go
// DownloadClient defines the interface for torrent client operations.
// This interface enables mocking in tests while the production code uses *putio.Client.
type DownloadClient interface {
    AddTransfer(ctx context.Context, magnetLink, parentName string) (*transfer.Transfer, error)
    AddTransferByBytes(ctx context.Context, content []byte, filename, parentName string) (*transfer.Transfer, error)
    GetTaggedTorrents(ctx context.Context, label string) ([]*transfer.Transfer, error)
    RemoveTransfers(ctx context.Context, ids []string, deleteData bool) error
}
```

2. Change TransmissionHandler to use the interface:
```go
type TransmissionHandler struct {
    username    string
    password    string
    dc          DownloadClient  // Changed from *putio.Client to interface
    label       string
    downloadDir string
    telemetry   *telemetry.Telemetry
}
```

3. Update NewTransmissionHandler signature:
```go
func NewTransmissionHandler(username, password string, dc DownloadClient, label string, downloadDir string, t *telemetry.Telemetry) *TransmissionHandler {
```

Note: `*putio.Client` already implements all these methods, so the concrete type satisfies the interface automatically.

**Interaction with Plan 01:** Plan 01 modifies `NewTransmissionHandler` to add a telemetry parameter and updates main.go accordingly. This plan (03) builds on that by:
1. Changing the `dc` parameter type from `*putio.Client` to `DownloadClient` interface
2. The main.go call added by Plan 01 (`NewTransmissionHandler(..., t)`) continues to work because `*putio.Client` satisfies `DownloadClient`
3. No additional main.go changes are required - the interface change is transparent to callers

**Part B: Add mock client (transmission_test.go)**

Add mock client implementation after imports:

```go
// mockPutioClient implements DownloadClient interface for testing.
type mockPutioClient struct {
    addTransferFunc          func(ctx context.Context, magnetLink, parentName string) (*transfer.Transfer, error)
    addTransferByBytesFunc   func(ctx context.Context, content []byte, filename, parentName string) (*transfer.Transfer, error)
    addTransferCalled        bool
    addTransferByBytesCalled bool
    lastMagnetLink           string
    lastFilename             string
    lastParentName           string
}

func (m *mockPutioClient) AddTransfer(ctx context.Context, magnetLink, parentName string) (*transfer.Transfer, error) {
    m.addTransferCalled = true
    m.lastMagnetLink = magnetLink
    m.lastParentName = parentName
    if m.addTransferFunc != nil {
        return m.addTransferFunc(ctx, magnetLink, parentName)
    }
    return &transfer.Transfer{ID: "mock-transfer-id", Name: "mock-transfer"}, nil
}

func (m *mockPutioClient) AddTransferByBytes(ctx context.Context, content []byte, filename, parentName string) (*transfer.Transfer, error) {
    m.addTransferByBytesCalled = true
    m.lastFilename = filename
    m.lastParentName = parentName
    if m.addTransferByBytesFunc != nil {
        return m.addTransferByBytesFunc(ctx, content, filename, parentName)
    }
    return &transfer.Transfer{ID: "mock-transfer-id", Name: "mock-transfer"}, nil
}

func (m *mockPutioClient) GetTaggedTorrents(ctx context.Context, label string) ([]*transfer.Transfer, error) {
    return []*transfer.Transfer{}, nil
}

func (m *mockPutioClient) RemoveTransfers(ctx context.Context, ids []string, deleteData bool) error {
    return nil
}
```
  </action>
  <verify>
Run `go build ./...` - should compile (both production code and tests).
Run `go vet ./...` - should pass.
Verify: `grep -n "DownloadClient interface" internal/http/rest/transmission.go` - interface exists.
Verify: `grep -n "dc.*DownloadClient" internal/http/rest/transmission.go` - handler uses interface.
  </verify>
  <done>
DownloadClient interface defined, TransmissionHandler refactored to use interface, mock client implements interface for tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for MetaInfo and magnet link handling</name>
  <files>internal/http/rest/transmission_test.go</files>
  <action>
Add integration tests using httptest. Append to transmission_test.go:

```go
import (
    "context"
    "encoding/base64"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "os"
    "strings"
    // ... existing imports
)

func TestHandleTorrentAdd_MetaInfo_Success(t *testing.T) {
    // Create valid bencode content
    validTorrent := []byte("d4:infod4:name4:testee")
    metainfo := base64.StdEncoding.EncodeToString(validTorrent)

    mockClient := &mockPutioClient{
        addTransferByBytesFunc: func(ctx context.Context, content []byte, filename, parentName string) (*transfer.Transfer, error) {
            return &transfer.Transfer{
                ID:   "12345",
                Name: "test-transfer",
            }, nil
        },
    }

    // Note: If TransmissionHandler uses *putio.Client directly, this test
    // may need adjustment. The test assumes we can inject a mock client.
    // If not possible, document the limitation and test what we can.
    handler := NewTransmissionHandler("testuser", "testpass", mockClient, "test-label", "/downloads", nil)

    reqBody := fmt.Sprintf(`{
        "method": "torrent-add",
        "arguments": {
            "metainfo": "%s"
        }
    }`, metainfo)

    req := httptest.NewRequest(http.MethodPost, "/transmission/rpc", strings.NewReader(reqBody))
    req.SetBasicAuth("testuser", "testpass")

    w := httptest.NewRecorder()
    handler.Routes().ServeHTTP(w, req)

    require.Equal(t, http.StatusOK, w.Code, "expected HTTP 200")

    var resp TransmissionResponse
    require.NoError(t, json.Unmarshal(w.Body.Bytes(), &resp))
    require.Equal(t, "success", resp.Result)
    require.Contains(t, string(resp.Arguments), "torrent-added")

    // Verify correct method was called
    require.True(t, mockClient.addTransferByBytesCalled, "AddTransferByBytes should be called for metainfo")
    require.False(t, mockClient.addTransferCalled, "AddTransfer should not be called for metainfo")
}

func TestHandleTorrentAdd_MagnetLink_BackwardCompatibility(t *testing.T) {
    mockClient := &mockPutioClient{
        addTransferFunc: func(ctx context.Context, magnetLink, parentName string) (*transfer.Transfer, error) {
            return &transfer.Transfer{
                ID:   "67890",
                Name: "magnet-transfer",
            }, nil
        },
    }

    handler := NewTransmissionHandler("testuser", "testpass", mockClient, "test-label", "/downloads", nil)

    reqBody := `{
        "method": "torrent-add",
        "arguments": {
            "filename": "magnet:?xt=urn:btih:ABCDEF1234567890ABCDEF1234567890ABCDEF12&dn=Test+Torrent"
        }
    }`

    req := httptest.NewRequest(http.MethodPost, "/transmission/rpc", strings.NewReader(reqBody))
    req.SetBasicAuth("testuser", "testpass")

    w := httptest.NewRecorder()
    handler.Routes().ServeHTTP(w, req)

    require.Equal(t, http.StatusOK, w.Code, "expected HTTP 200")

    var resp TransmissionResponse
    require.NoError(t, json.Unmarshal(w.Body.Bytes(), &resp))
    require.Equal(t, "success", resp.Result)
    require.Contains(t, string(resp.Arguments), "torrent-added")

    // Verify correct method was called - this is the key backward compatibility check
    require.True(t, mockClient.addTransferCalled, "AddTransfer should be called for magnet links")
    require.False(t, mockClient.addTransferByBytesCalled, "AddTransferByBytes should not be called for magnet links")
    require.Contains(t, mockClient.lastMagnetLink, "magnet:", "magnet link should be passed to AddTransfer")
}

func TestHandleTorrentAdd_MetaInfo_PrioritizedOverFileName(t *testing.T) {
    // When both MetaInfo and FileName are present, MetaInfo should be used (API-06)
    validTorrent := []byte("d4:infod4:name4:testee")
    metainfo := base64.StdEncoding.EncodeToString(validTorrent)

    mockClient := &mockPutioClient{}

    handler := NewTransmissionHandler("testuser", "testpass", mockClient, "test-label", "/downloads", nil)

    // Request with BOTH metainfo and filename
    reqBody := fmt.Sprintf(`{
        "method": "torrent-add",
        "arguments": {
            "metainfo": "%s",
            "filename": "magnet:?xt=urn:btih:IGNORED"
        }
    }`, metainfo)

    req := httptest.NewRequest(http.MethodPost, "/transmission/rpc", strings.NewReader(reqBody))
    req.SetBasicAuth("testuser", "testpass")

    w := httptest.NewRecorder()
    handler.Routes().ServeHTTP(w, req)

    require.Equal(t, http.StatusOK, w.Code)

    // MetaInfo should be prioritized - AddTransferByBytes called, not AddTransfer
    require.True(t, mockClient.addTransferByBytesCalled, "MetaInfo should be prioritized over FileName")
    require.False(t, mockClient.addTransferCalled, "FileName should be ignored when MetaInfo present")
}

func TestHandleTorrentAdd_InvalidBase64_ReturnsTransmissionError(t *testing.T) {
    mockClient := &mockPutioClient{}
    handler := NewTransmissionHandler("testuser", "testpass", mockClient, "test-label", "/downloads", nil)

    // Invalid base64 - contains characters not in base64 alphabet
    reqBody := `{
        "method": "torrent-add",
        "arguments": {
            "metainfo": "!!!invalid-base64!!!"
        }
    }`

    req := httptest.NewRequest(http.MethodPost, "/transmission/rpc", strings.NewReader(reqBody))
    req.SetBasicAuth("testuser", "testpass")

    w := httptest.NewRecorder()
    handler.Routes().ServeHTTP(w, req)

    // Transmission protocol: HTTP 200 with error in result field
    require.Equal(t, http.StatusOK, w.Code, "Transmission errors should return HTTP 200")

    var resp TransmissionResponse
    require.NoError(t, json.Unmarshal(w.Body.Bytes(), &resp))
    require.Contains(t, resp.Result, "invalid torrent", "error should indicate invalid torrent")
    require.Contains(t, resp.Result, "base64", "error should mention base64")
}

func TestHandleTorrentAdd_InvalidBencode_ReturnsTransmissionError(t *testing.T) {
    mockClient := &mockPutioClient{}
    handler := NewTransmissionHandler("testuser", "testpass", mockClient, "test-label", "/downloads", nil)

    // Valid base64 but invalid bencode content
    invalidBencode := base64.StdEncoding.EncodeToString([]byte("not valid bencode"))

    reqBody := fmt.Sprintf(`{
        "method": "torrent-add",
        "arguments": {
            "metainfo": "%s"
        }
    }`, invalidBencode)

    req := httptest.NewRequest(http.MethodPost, "/transmission/rpc", strings.NewReader(reqBody))
    req.SetBasicAuth("testuser", "testpass")

    w := httptest.NewRecorder()
    handler.Routes().ServeHTTP(w, req)

    require.Equal(t, http.StatusOK, w.Code, "Transmission errors should return HTTP 200")

    var resp TransmissionResponse
    require.NoError(t, json.Unmarshal(w.Body.Bytes(), &resp))
    require.Contains(t, resp.Result, "invalid torrent", "error should indicate invalid torrent")
    require.Contains(t, resp.Result, "bencode", "error should mention bencode")
}

func TestHandleTorrentAdd_AuthenticationRequired(t *testing.T) {
    mockClient := &mockPutioClient{}
    handler := NewTransmissionHandler("testuser", "testpass", mockClient, "test-label", "/downloads", nil)

    reqBody := `{"method": "torrent-add", "arguments": {"filename": "magnet:?xt=urn:btih:TEST"}}`

    // Request without authentication
    req := httptest.NewRequest(http.MethodPost, "/transmission/rpc", strings.NewReader(reqBody))
    // Note: NOT calling req.SetBasicAuth()

    w := httptest.NewRecorder()
    handler.Routes().ServeHTTP(w, req)

    require.Equal(t, http.StatusUnauthorized, w.Code, "missing auth should return 401")
}

func TestHandleTorrentAdd_WrongCredentials(t *testing.T) {
    mockClient := &mockPutioClient{}
    handler := NewTransmissionHandler("testuser", "testpass", mockClient, "test-label", "/downloads", nil)

    reqBody := `{"method": "torrent-add", "arguments": {"filename": "magnet:?xt=urn:btih:TEST"}}`

    req := httptest.NewRequest(http.MethodPost, "/transmission/rpc", strings.NewReader(reqBody))
    req.SetBasicAuth("wronguser", "wrongpass")

    w := httptest.NewRecorder()
    handler.Routes().ServeHTTP(w, req)

    require.Equal(t, http.StatusUnauthorized, w.Code, "wrong credentials should return 401")
}

// TestHandleTorrentAdd_RealTorrentFile tests with a real .torrent file fixture (TEST-03 requirement).
// This test is skipped if the fixture file is not present - obtain a valid .torrent from your tracker.
func TestHandleTorrentAdd_RealTorrentFile(t *testing.T) {
    torrentPath := "testdata/valid.torrent"
    torrentData, err := os.ReadFile(torrentPath)
    if os.IsNotExist(err) {
        t.Skip("Skipping: testdata/valid.torrent not present. See testdata/README.md for instructions.")
    }
    require.NoError(t, err, "failed to read torrent file")

    metainfo := base64.StdEncoding.EncodeToString(torrentData)

    mockClient := &mockPutioClient{
        addTransferByBytesFunc: func(ctx context.Context, content []byte, filename, parentName string) (*transfer.Transfer, error) {
            // Verify the content matches what we sent
            require.Equal(t, torrentData, content, "torrent content should match fixture")
            return &transfer.Transfer{ID: "real-torrent-id", Name: "real-transfer"}, nil
        },
    }

    handler := NewTransmissionHandler("testuser", "testpass", mockClient, "test-label", "/downloads", nil)

    reqBody := fmt.Sprintf(`{
        "method": "torrent-add",
        "arguments": {
            "metainfo": "%s"
        }
    }`, metainfo)

    req := httptest.NewRequest(http.MethodPost, "/transmission/rpc", strings.NewReader(reqBody))
    req.SetBasicAuth("testuser", "testpass")

    w := httptest.NewRecorder()
    handler.Routes().ServeHTTP(w, req)

    require.Equal(t, http.StatusOK, w.Code, "expected HTTP 200")

    var resp TransmissionResponse
    require.NoError(t, json.Unmarshal(w.Body.Bytes(), &resp))
    require.Equal(t, "success", resp.Result, "should successfully process real torrent file")
    require.True(t, mockClient.addTransferByBytesCalled, "AddTransferByBytes should be called")
}
```

**Important:** If `NewTransmissionHandler` requires `*putio.Client` specifically (not an interface), we have two options:
1. Refactor to use an interface (more work, better testability)
2. Test only what we can without mocking the client (limited but still valuable)

Check the actual signature and adjust accordingly. If mocking isn't possible, remove the mock-dependent assertions and focus on testing input validation, auth, and response formatting.
  </action>
  <verify>
Run `go test -v ./internal/http/rest/... -run TestHandleTorrentAdd` - all tests should pass.
If tests fail due to type mismatch with *putio.Client, document the limitation in the test file comments.
  </verify>
  <done>
Integration tests verify MetaInfo success, magnet link backward compatibility, MetaInfo priority over FileName, error response format, and authentication.
  </done>
</task>

</tasks>

<verification>
1. `go test -v ./internal/http/rest/...` - all tests pass
2. `go test -cover ./internal/http/rest/...` - shows increased coverage
3. Tests verify backward compatibility: magnet links call AddTransfer (TEST-04)
4. Tests verify MetaInfo handling: MetaInfo field calls AddTransferByBytes (TEST-03)
5. Tests verify error format: HTTP 200 with error in result (Transmission protocol)
6. TestHandleTorrentAdd_RealTorrentFile skips gracefully if fixture not present, passes if fixture exists (TEST-03)
</verification>

<success_criteria>
- Integration tests pass using httptest
- Backward compatibility verified: magnet links work identically (TEST-04)
- MetaInfo handling verified with valid bencode and real .torrent fixture when available (TEST-03)
- Error responses follow Transmission protocol (HTTP 200 with error in result)
- Authentication middleware tested
- Real .torrent file test skips gracefully when fixture absent, runs when present
</success_criteria>

<output>
After completion, create `.planning/phases/06-observability-a-testing/06-03-SUMMARY.md`
</output>
