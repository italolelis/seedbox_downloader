---
phase: 06-observability-a-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/http/rest/transmission_test.go
  - internal/http/rest/testdata/README.md
autonomous: true

must_haves:
  truths:
    - "Base64 decoding edge cases are tested (invalid chars, wrong padding, empty string, wrong variant URLEncoding)"
    - "Bencode validation tests cover malformed structure and missing info field"
    - "Tests use table-driven pattern with testify/require"
  artifacts:
    - path: "internal/http/rest/transmission_test.go"
      provides: "Unit tests for validateBencodeStructure and base64 edge cases"
      contains: "TestValidateBencodeStructure"
    - path: "internal/http/rest/testdata/README.md"
      provides: "Documentation for test data directory"
      contains: "testdata"
  key_links:
    - from: "internal/http/rest/transmission_test.go"
      to: "internal/http/rest/transmission.go"
      via: "Direct function call to validateBencodeStructure"
      pattern: "validateBencodeStructure"
---

<objective>
Create unit tests for base64 decoding edge cases and bencode validation logic in the Transmission handler.

Purpose: Ensure .torrent file validation catches invalid input before uploading to Put.io, preventing silent failures and providing clear error messages.
Output: Comprehensive unit tests for validation helper functions with table-driven test patterns.
</objective>

<execution_context>
@/Users/italovietro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/italovietro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-observability-a-testing/06-RESEARCH.md
@internal/http/rest/transmission.go
@internal/transfer/errors_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create testdata directory with README</name>
  <files>internal/http/rest/testdata/README.md</files>
  <action>
Create the testdata directory structure for test fixtures:

1. Create directory: internal/http/rest/testdata/

2. Create README.md with content:
```markdown
# Test Data

This directory contains test fixtures for the Transmission RPC handler tests.

## Files

### Bencode Test Data
Test bencode strings are generated inline in `transmission_test.go` using Go string literals.
This approach avoids external file dependencies and makes test cases self-documenting.

### Real .torrent Files
For integration tests with real .torrent files:
1. Obtain a valid .torrent file from your tracker (e.g., amigos-share)
2. Place it in this directory as `valid.torrent`
3. The file is gitignored to avoid committing copyrighted metadata

Note: Integration tests that require real .torrent files will skip if the fixture is not present.

## Bencode Format Reference

Valid .torrent structure (simplified):
- Root: dictionary (`d...e`)
- Required field: `info` (dictionary with torrent metadata)
- Common fields: `announce`, `created by`, `creation date`

Example minimal valid bencode:
```
d4:infod4:name4:teste
```
Decoded: `{"info": {"name": "test"}}`

Example invalid cases:
- Not bencode: `not bencode data`
- List instead of dict: `l4:teste` (["test"])
- Missing info field: `d4:name4:teste` ({"name": "test"})
```
  </action>
  <verify>
Run `ls -la internal/http/rest/testdata/` - should show README.md file.
  </verify>
  <done>
testdata directory exists with documentation explaining test data conventions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for validateBencodeStructure function</name>
  <files>internal/http/rest/transmission_test.go</files>
  <action>
Create transmission_test.go with table-driven unit tests for bencode validation.

Use testify/require (not assert) per research findings - stops on first failure to prevent cascading errors.

```go
package rest

import (
    "encoding/base64"
    "errors"
    "fmt"
    "testing"

    "github.com/italolelis/seedbox_downloader/internal/transfer"
    "github.com/stretchr/testify/require"
)

func TestValidateBencodeStructure(t *testing.T) {
    tests := []struct {
        name        string
        data        []byte
        expectError bool
        errorReason string
    }{
        {
            name:        "valid torrent structure with info dict",
            data:        []byte("d4:infod4:name4:testee"),  // {"info": {"name": "test"}}
            expectError: false,
        },
        {
            name:        "valid torrent with announce",
            data:        []byte("d8:announce3:url4:infod4:name4:testee"),  // {"announce": "url", "info": {"name": "test"}}
            expectError: false,
        },
        {
            name:        "invalid bencode syntax - not bencode",
            data:        []byte("not bencode at all"),
            expectError: true,
            errorReason: "invalid bencode structure",
        },
        {
            name:        "invalid bencode syntax - truncated",
            data:        []byte("d4:info"),  // Incomplete dictionary
            expectError: true,
            errorReason: "invalid bencode structure",
        },
        {
            name:        "root is list not dictionary",
            data:        []byte("l4:teste"),  // ["test"]
            expectError: true,
            errorReason: "bencode root must be a dictionary",
        },
        {
            name:        "root is string not dictionary",
            data:        []byte("4:test"),  // "test"
            expectError: true,
            errorReason: "bencode root must be a dictionary",
        },
        {
            name:        "root is integer not dictionary",
            data:        []byte("i42e"),  // 42
            expectError: true,
            errorReason: "bencode root must be a dictionary",
        },
        {
            name:        "missing info field",
            data:        []byte("d4:name4:teste"),  // {"name": "test"} - no "info"
            expectError: true,
            errorReason: "bencode missing required 'info' dictionary",
        },
        {
            name:        "empty dictionary",
            data:        []byte("de"),  // {}
            expectError: true,
            errorReason: "bencode missing required 'info' dictionary",
        },
        {
            name:        "info is not dictionary",
            data:        []byte("d4:info4:teste"),  // {"info": "test"} - info is string
            expectError: false,  // Current implementation only checks for presence, not type
        },
        {
            name:        "empty data",
            data:        []byte{},
            expectError: true,
            errorReason: "invalid bencode structure",
        },
        {
            name:        "nil data treated as empty",
            data:        nil,
            expectError: true,
            errorReason: "invalid bencode structure",
        },
    }
```

**Test Base64 Decoding Edge Cases** (TEST-01 requirement - wrong variant):

Add a separate test function for base64 decoding edge cases, including the critical "wrong variant" test:

```go
func TestBase64DecodingEdgeCases(t *testing.T) {
    tests := []struct {
        name        string
        input       string
        expectError bool
        description string
    }{
        {
            name:        "valid StdEncoding base64",
            input:       base64.StdEncoding.EncodeToString([]byte("d4:infod4:name4:testee")),
            expectError: false,
            description: "Standard encoding should decode successfully",
        },
        {
            name:        "wrong variant - URLEncoding instead of StdEncoding",
            input:       base64.URLEncoding.EncodeToString([]byte("d4:infod4:name4:testee")),
            expectError: true,
            description: "URLEncoding uses -_ instead of +/ - StdEncoding decoder may fail or produce garbage",
        },
        {
            name:        "invalid characters",
            input:       "!!!invalid-base64!!!",
            expectError: true,
            description: "Non-base64 characters should fail",
        },
        {
            name:        "wrong padding",
            input:       "SGVsbG8gV29ybGQ",  // Missing padding (should be SGVsbG8gV29ybGQ=)
            expectError: false,  // Go's StdEncoding is lenient with padding in some cases
            description: "Missing padding may be tolerated by Go decoder",
        },
        {
            name:        "empty string",
            input:       "",
            expectError: true,  // Empty decodes to empty bytes, but bencode validation fails
            description: "Empty input produces empty bytes",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            decoded, err := base64.StdEncoding.DecodeString(tt.input)

            if tt.expectError {
                // Either base64 decode fails OR bencode validation fails
                if err != nil {
                    return  // Base64 decode failed - expected
                }
                // If decode succeeded, bencode validation should fail
                err = validateBencodeStructure(decoded)
                require.Error(t, err, "expected bencode validation to fail for: %s", tt.description)
            } else {
                require.NoError(t, err, "base64 decode should succeed for: %s", tt.description)
                // For valid cases, also check bencode validation passes
                if len(decoded) > 0 {
                    err = validateBencodeStructure(decoded)
                    require.NoError(t, err, "bencode validation should pass for: %s", tt.description)
                }
            }
        })
    }
}

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := validateBencodeStructure(tt.data)

            if tt.expectError {
                require.Error(t, err, "expected error for case: %s", tt.name)

                // Verify error type is InvalidContentError
                var invalidErr *transfer.InvalidContentError
                require.True(t, errors.As(err, &invalidErr),
                    "expected InvalidContentError, got %T", err)

                // Verify error reason contains expected substring
                require.Contains(t, invalidErr.Reason, tt.errorReason,
                    "error reason should contain %q", tt.errorReason)
            } else {
                require.NoError(t, err, "unexpected error for case: %s", tt.name)
            }
        })
    }
}

func TestGenerateTorrentFilename(t *testing.T) {
    tests := []struct {
        name     string
        data     []byte
        wantLen  int
        wantExt  string
    }{
        {
            name:    "generates hash-based filename",
            data:    []byte("d4:infod4:name4:testee"),
            wantLen: 24,  // 16 chars hash + ".torrent" (8 chars)
            wantExt: ".torrent",
        },
        {
            name:    "different content produces different filename",
            data:    []byte("d4:infod4:name7:anothere"),
            wantLen: 24,
            wantExt: ".torrent",
        },
        {
            name:    "empty content still generates filename",
            data:    []byte{},
            wantLen: 24,
            wantExt: ".torrent",
        },
    }

    var previousFilename string
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            filename := generateTorrentFilename(tt.data)

            require.Len(t, filename, tt.wantLen,
                "filename should be %d characters", tt.wantLen)

            require.True(t, len(filename) > len(tt.wantExt),
                "filename should be longer than extension")

            ext := filename[len(filename)-len(tt.wantExt):]
            require.Equal(t, tt.wantExt, ext,
                "filename should end with %s", tt.wantExt)

            // Verify different content produces different filename
            if previousFilename != "" && tt.name == "different content produces different filename" {
                require.NotEqual(t, previousFilename, filename,
                    "different content should produce different filename")
            }
            previousFilename = filename
        })
    }
}

func TestFormatTransmissionError(t *testing.T) {
    tests := []struct {
        name     string
        err      error
        expected string
    }{
        {
            name: "InvalidContentError formatting",
            err: &transfer.InvalidContentError{
                Filename: "test.torrent",
                Reason:   "invalid base64 encoding",
            },
            expected: "invalid torrent: invalid base64 encoding",
        },
        {
            name: "NetworkError formatting",
            err: &transfer.NetworkError{
                Operation:  "upload",
                StatusCode: 503,
                APIMessage: "service unavailable",
            },
            expected: "upload failed: service unavailable",
        },
        {
            name: "DirectoryError formatting",
            err: &transfer.DirectoryError{
                DirectoryName: "itv",
                Reason:        "not found",
            },
            expected: "directory error: not found",
        },
        {
            name: "AuthenticationError formatting",
            err: &transfer.AuthenticationError{
                Operation: "upload",
            },
            expected: "authentication failed",
        },
        {
            name:     "generic error formatting",
            err:      errors.New("something went wrong"),
            expected: "error: something went wrong",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := formatTransmissionError(tt.err)
            require.Equal(t, tt.expected, result)
        })
    }
}
```
  </action>
  <verify>
Run `go test -v ./internal/http/rest/... -run TestValidateBencodeStructure` - all tests should pass.
Run `go test -v ./internal/http/rest/... -run TestGenerateTorrentFilename` - all tests should pass.
Run `go test -v ./internal/http/rest/... -run TestFormatTransmissionError` - all tests should pass.
Run `go test -v ./internal/http/rest/... -run TestBase64DecodingEdgeCases` - all tests should pass.
  </verify>
  <done>
Unit tests exist for validateBencodeStructure, generateTorrentFilename, formatTransmissionError, and base64 decoding edge cases (including wrong variant TEST-01).
  </done>
</task>

</tasks>

<verification>
1. `go test -v ./internal/http/rest/...` - all tests pass
2. `go test -cover ./internal/http/rest/...` - shows coverage for transmission.go
3. `grep -n "TestValidateBencodeStructure" internal/http/rest/transmission_test.go` - test exists
4. `grep -n "TestGenerateTorrentFilename" internal/http/rest/transmission_test.go` - test exists
5. `grep -n "TestFormatTransmissionError" internal/http/rest/transmission_test.go` - test exists
</verification>

<success_criteria>
- TestValidateBencodeStructure covers: invalid syntax, wrong root type, missing info field
- TestGenerateTorrentFilename verifies hash-based filename generation
- TestFormatTransmissionError verifies all custom error type mappings
- All tests use testify/require (not assert)
- Tests pass with `go test ./internal/http/rest/...`
</success_criteria>

<output>
After completion, create `.planning/phases/06-observability-a-testing/06-02-SUMMARY.md`
</output>
