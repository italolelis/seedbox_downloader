---
phase: 05-transmission-api-handler
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - internal/http/rest/transmission.go
autonomous: true

must_haves:
  truths:
    - "Invalid .torrent content returns HTTP 200 with error in result field"
    - "Custom error types (InvalidContentError, NetworkError) map to specific error messages"
    - "Malformed JSON requests still return HTTP 400"
    - "Transmission clients receive actionable error messages in result field"
    - "Server errors (encode failures) still return HTTP 500"
  artifacts:
    - path: "internal/http/rest/transmission.go"
      provides: "Transmission-compatible error response formatting"
      contains: "formatTransmissionError"
    - path: "internal/http/rest/transmission.go"
      provides: "Error handling in HandleRPC returns HTTP 200 with error in result"
      contains: "Result: formatTransmissionError"
  key_links:
    - from: "HandleRPC"
      to: "formatTransmissionError"
      via: "error handling block"
      pattern: "formatTransmissionError\\(err\\)"
    - from: "formatTransmissionError"
      to: "transfer.InvalidContentError"
      via: "errors.As type inspection"
      pattern: "errors\\.As\\(err,\\s*&invalidErr\\)"
---

<objective>
Fix Transmission API error responses to follow Transmission RPC protocol

Purpose: Transmission clients (including Sonarr/Radarr) expect HTTP 200 with errors in the `result` field, not HTTP 4xx/5xx status codes. This ensures clients can display specific error messages to users.

Output:
- formatTransmissionError function that maps custom error types to user-friendly messages
- Updated HandleRPC that returns HTTP 200 with error in result field for RPC failures
- Preserved HTTP 400 for malformed JSON (not an RPC error)
</objective>

<execution_context>
@/Users/italovietro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/italovietro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-transmission-api-handler/05-RESEARCH.md
@.planning/phases/05-transmission-api-handler/05-01-SUMMARY.md
@internal/http/rest/transmission.go
@internal/transfer/errors.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add formatTransmissionError function</name>
  <files>internal/http/rest/transmission.go</files>
  <action>
Add the `formatTransmissionError` function that maps custom error types to Transmission-compatible error messages.

**Add import if not already present:**
```go
import "errors"
```

**Add function (place after handleTorrentGet or near bottom of file):**

```go
// formatTransmissionError converts internal errors to Transmission-compatible error messages.
// Transmission RPC uses the "result" field for error reporting - this function
// produces user-friendly error messages for common failure cases.
func formatTransmissionError(err error) string {
    var invalidErr *transfer.InvalidContentError
    if errors.As(err, &invalidErr) {
        return fmt.Sprintf("invalid torrent: %s", invalidErr.Reason)
    }

    var networkErr *transfer.NetworkError
    if errors.As(err, &networkErr) {
        return fmt.Sprintf("upload failed: %s", networkErr.APIMessage)
    }

    var dirErr *transfer.DirectoryError
    if errors.As(err, &dirErr) {
        return fmt.Sprintf("directory error: %s", dirErr.Reason)
    }

    var authErr *transfer.AuthenticationError
    if errors.As(err, &authErr) {
        return "authentication failed"
    }

    // Generic fallback for unknown errors
    return fmt.Sprintf("error: %v", err)
}
```

**Error message design rationale:**
- Messages are high-level (e.g., "invalid torrent: invalid base64 encoding") without exposing internal stack traces
- Messages are actionable - users understand what went wrong
- Custom error types carry context (Reason, APIMessage) that gets surfaced
- Generic errors are wrapped with "error:" prefix for consistency
  </action>
  <verify>
Run:
```bash
go build ./...
go vet ./internal/http/rest/...
grep -n "func formatTransmissionError" internal/http/rest/transmission.go
```

Verify function exists and compiles without errors.
  </verify>
  <done>
formatTransmissionError function handles InvalidContentError, NetworkError, DirectoryError, AuthenticationError, and generic errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update HandleRPC error handling for Transmission compatibility</name>
  <files>internal/http/rest/transmission.go</files>
  <action>
Update the `HandleRPC` method to return HTTP 200 with error in `result` field instead of using `http.Error()` for RPC failures.

**Current problematic code (around lines 186-191):**
```go
if err != nil {
    logger.Error("failed to handle request", "method", req.Method, "err", err)
    http.Error(w, err.Error(), http.StatusBadRequest)
    return
}
```

**Replace with Transmission-compatible error handling:**
```go
if err != nil {
    logger.Error("failed to handle request", "method", req.Method, "err", err)

    // Transmission RPC returns HTTP 200 with error in result field
    // This allows clients to display specific error messages
    errorResponse := &TransmissionResponse{
        Result: formatTransmissionError(err),
    }

    w.Header().Set("Content-Type", "application/json")
    if encodeErr := json.NewEncoder(w).Encode(errorResponse); encodeErr != nil {
        // Only use HTTP error for server-side failures (encoding)
        logger.Error("failed to encode error response", "err", encodeErr)
        http.Error(w, "internal server error", http.StatusInternalServerError)
    }
    return
}
```

**Important: Preserve HTTP 400 for malformed JSON**

The existing JSON decode error handling (around lines 134-139) should remain unchanged:
```go
if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    logger.Error("failed to decode request", "err", err)
    http.Error(w, "invalid request body", http.StatusBadRequest)
    return
}
```

This is correct because:
- Malformed JSON is not a valid RPC request
- Clients cannot parse the response body anyway
- HTTP 400 is appropriate for protocol violations

**Also preserve HTTP 400 for unknown methods (around line 181):**
```go
default:
    logger.Error("unknown method", "method", req.Method)
    http.Error(w, fmt.Sprintf("unknown method %s", req.Method), http.StatusBadRequest)
    return
```

**Summary of HTTP status code usage:**
| Scenario | HTTP Status | Response Body |
|----------|-------------|---------------|
| RPC error (torrent add fails) | 200 | `{"result": "invalid torrent: ..."}`  |
| Malformed JSON body | 400 | `"invalid request body"` |
| Unknown RPC method | 400 | `"unknown method X"` |
| Server encode error | 500 | `"internal server error"` |
  </action>
  <verify>
Run:
```bash
go build ./...
go vet ./internal/http/rest/...
```

Verify the error handling block after `switch req.Method` case handling:
```bash
grep -A10 "if err != nil" internal/http/rest/transmission.go | grep -q "formatTransmissionError"
```
  </verify>
  <done>
- RPC errors return HTTP 200 with error message in result field (API-04)
- Malformed JSON requests still return HTTP 400
- Unknown method requests still return HTTP 400
- Server encoding errors return HTTP 500
- Transmission clients receive specific, actionable error messages
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   go build ./...
   go vet ./...
   ```

2. **Function existence check:**
   ```bash
   grep -n "func formatTransmissionError" internal/http/rest/transmission.go
   ```

3. **Error handling pattern verification:**
   ```bash
   # Should NOT find http.Error after switch block for err handling
   # Should find formatTransmissionError usage
   grep -A15 "if err != nil" internal/http/rest/transmission.go | tail -10
   ```

4. **HTTP 400 preserved for malformed JSON:**
   ```bash
   grep -B2 -A2 "invalid request body" internal/http/rest/transmission.go
   ```

5. **All error types handled:**
   ```bash
   grep -c "errors.As" internal/http/rest/transmission.go  # Should be 4 (one per error type)
   ```
</verification>

<success_criteria>
- [ ] `go build ./...` succeeds
- [ ] `go vet ./...` reports no issues
- [ ] formatTransmissionError function exists and handles all 4 custom error types
- [ ] HandleRPC returns HTTP 200 with error in result field for RPC failures
- [ ] HandleRPC returns HTTP 400 for malformed JSON (unchanged)
- [ ] HandleRPC returns HTTP 400 for unknown methods (unchanged)
- [ ] errors.As is used for type-safe error inspection
</success_criteria>

<output>
After completion, create `.planning/phases/05-transmission-api-handler/05-02-SUMMARY.md`
</output>
