---
phase: 02-resource-leak-prevention
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/transfer/transfer.go
autonomous: true

must_haves:
  truths:
    - "ProduceTransfers ticker is stopped on context cancellation"
    - "ProduceTransfers ticker is stopped if goroutine panics"
    - "Goroutine logs exit reason (context cancelled, panic)"
    - "Goroutine restarts after panic if context not cancelled"
  artifacts:
    - path: "internal/transfer/transfer.go"
      provides: "Ticker cleanup and panic recovery in ProduceTransfers"
      contains: "defer ticker.Stop()"
  key_links:
    - from: "ProduceTransfers goroutine"
      to: "ticker.Stop()"
      via: "defer statement"
      pattern: "defer ticker\\.Stop\\(\\)"
    - from: "ProduceTransfers goroutine"
      to: "recover()"
      via: "deferred panic recovery"
      pattern: "defer func\\(\\).*recover\\(\\)"
---

<objective>
Add proper ticker cleanup and panic recovery to TransferOrchestrator.ProduceTransfers goroutine.

Purpose: Prevent ticker resource leaks and ensure goroutine resilience for 24/7 operation.
Output: Modified transfer.go with defer-based ticker cleanup, panic recovery with restart, and exit logging.
</objective>

<execution_context>
@/Users/italovietro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/italovietro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-resource-leak-prevention/02-CONTEXT.md
@.planning/phases/02-resource-leak-prevention/02-RESEARCH.md
@internal/transfer/transfer.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ticker cleanup and panic recovery to ProduceTransfers</name>
  <files>internal/transfer/transfer.go</files>
  <action>
Modify the ProduceTransfers method (lines 91-142) to add proper resource cleanup:

1. Add import for "runtime/debug" at the top of the file (for stack traces in panic recovery)

2. Inside the goroutine (after `go func() {`), add deferred panic recovery FIRST (executes last during unwind):
```go
defer func() {
    if r := recover(); r != nil {
        logger.Error("transfer orchestrator panic",
            "operation", "produce_transfers",
            "panic", r,
            "stack", string(debug.Stack()))

        // Restart with clean state if context not cancelled
        if ctx.Err() == nil {
            logger.Info("restarting transfer orchestrator after panic",
                "operation", "produce_transfers")
            time.Sleep(time.Second) // Brief backoff before restart
            o.ProduceTransfers(ctx)
        }
    }
}()
```

3. Move ticker creation AFTER the panic recovery defer, then add ticker cleanup defer:
```go
ticker := time.NewTicker(o.pollingInterval)
defer ticker.Stop()
```

4. In the ctx.Done case, REMOVE the `ticker.Stop()` call (defer handles it) and add structured exit logging:
```go
case <-ctx.Done():
    logger.Info("transfer orchestrator shutdown",
        "operation", "produce_transfers",
        "reason", "context_cancelled")
    return
```

The final goroutine structure should be:
```go
go func() {
    // Panic recovery (deferred last, executes first during unwind)
    defer func() {
        if r := recover(); r != nil {
            // ... recovery logic with restart
        }
    }()

    // Ticker with cleanup (deferred second, executes second during unwind)
    ticker := time.NewTicker(o.pollingInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            logger.Info("transfer orchestrator shutdown", ...)
            return
        case <-ticker.C:
            // ... existing work
        }
    }
}()
```

Keep the existing work logic in the ticker case unchanged.
  </action>
  <verify>
Run `go build ./...` - should compile without errors.
Run `go vet ./...` - should pass with no issues.
Grep for defer pattern: `grep -n "defer ticker.Stop()" internal/transfer/transfer.go` returns line number.
Grep for panic recovery: `grep -n "recover()" internal/transfer/transfer.go` returns line number.
Grep for removed inline Stop: `grep -n "ticker.Stop()" internal/transfer/transfer.go` returns ONLY the defer line.
  </verify>
  <done>
- ProduceTransfers has `defer ticker.Stop()` immediately after ticker creation
- ProduceTransfers has deferred panic recovery with stack trace logging and conditional restart
- ctx.Done case logs structured exit with "operation" and "reason" fields
- No inline `ticker.Stop()` calls remain in select cases
- Code compiles and passes vet
  </done>
</task>

</tasks>

<verification>
After completing the task:
1. `go build ./...` passes
2. `go vet ./...` passes
3. `grep -c "defer ticker.Stop()" internal/transfer/transfer.go` returns 1
4. `grep -c "recover()" internal/transfer/transfer.go` returns 1
5. Code structure matches the pattern from 02-RESEARCH.md
</verification>

<success_criteria>
- TransferOrchestrator.ProduceTransfers uses defer for ticker cleanup
- Panic recovery is in place with stack trace logging
- Restart logic only triggers if context is not cancelled
- Exit logging uses structured fields (operation, reason)
- Requirement RES-02 is satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-resource-leak-prevention/02-01-SUMMARY.md`
</output>
