---
phase: 02-resource-leak-prevention
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/downloader/downloader.go
autonomous: true

must_haves:
  truths:
    - "WatchForImported ticker is stopped on context cancellation"
    - "WatchForImported ticker is stopped when transfer is imported"
    - "WatchForSeeding ticker is stopped on context cancellation"
    - "WatchForSeeding ticker is stopped when transfer stops seeding"
    - "Both goroutines recover from panics and log with stack traces"
    - "Exit scenarios are logged with operation and reason fields"
  artifacts:
    - path: "internal/downloader/downloader.go"
      provides: "Ticker cleanup and panic recovery in watch loops"
      contains: "defer ticker.Stop()"
  key_links:
    - from: "WatchForImported goroutine"
      to: "ticker.Stop()"
      via: "defer statement"
      pattern: "defer ticker\\.Stop\\(\\)"
    - from: "WatchForSeeding goroutine"
      to: "ticker.Stop()"
      via: "defer statement"
      pattern: "defer ticker\\.Stop\\(\\)"
---

<objective>
Add proper ticker cleanup and panic recovery to Downloader.WatchForImported and WatchForSeeding goroutines.

Purpose: Prevent ticker resource leaks in both watch loops and ensure goroutine resilience.
Output: Modified downloader.go with defer-based ticker cleanup, panic recovery, and exit logging for both methods.
</objective>

<execution_context>
@/Users/italovietro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/italovietro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-resource-leak-prevention/02-CONTEXT.md
@.planning/phases/02-resource-leak-prevention/02-RESEARCH.md
@internal/downloader/downloader.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ticker cleanup and panic recovery to WatchForImported</name>
  <files>internal/downloader/downloader.go</files>
  <action>
Add import for "runtime/debug" at the top of the file (for stack traces).

Modify WatchForImported method (lines 183-215) to add proper resource cleanup:

1. Inside the goroutine (after `go func() {`), add deferred panic recovery FIRST:
```go
defer func() {
    if r := recover(); r != nil {
        logger.Error("watch imported panic",
            "operation", "watch_imported",
            "transfer_id", t.ID,
            "panic", r,
            "stack", string(debug.Stack()))
        // No restart for per-transfer watch - let transfer be picked up again on next cycle
    }
}()
```

2. Move ticker creation after panic recovery, add defer:
```go
ticker := time.NewTicker(pollingInterval)
defer ticker.Stop()
```

3. In ctx.Done case, add structured exit logging:
```go
case <-ctx.Done():
    logger.Info("watch imported shutdown",
        "operation", "watch_imported",
        "transfer_id", t.ID,
        "reason", "context_cancelled")
    return
```

4. In the ticker case when imported is true, REMOVE the `ticker.Stop()` call (defer handles it), log the completion, and return cleanly:
```go
if imported {
    logger.Info("transfer imported, stopping watch",
        "operation", "watch_imported",
        "transfer_id", t.ID,
        "reason", "transfer_imported")
    d.OnTransferImported <- t
    return  // Changed from break to return - defer will stop ticker
}
```

Note: Change `break` to `return` so the goroutine exits cleanly and defer runs.
  </action>
  <verify>
Run `go build ./...` to check compilation.
Grep: `grep -A5 "func (d \*Downloader) WatchForImported" internal/downloader/downloader.go` shows the method.
Grep: `grep -n "defer ticker.Stop()" internal/downloader/downloader.go` returns at least one line for this method.
  </verify>
  <done>
- WatchForImported has `defer ticker.Stop()` immediately after ticker creation
- WatchForImported has deferred panic recovery with stack trace logging
- ctx.Done case logs structured exit with transfer_id
- Import completion case uses return (not break) so defer executes
- No inline `ticker.Stop()` calls remain in WatchForImported
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ticker cleanup and panic recovery to WatchForSeeding</name>
  <files>internal/downloader/downloader.go</files>
  <action>
Modify WatchForSeeding method (lines 217-250) to add proper resource cleanup:

1. Inside the goroutine (after `go func() {`), add deferred panic recovery FIRST:
```go
defer func() {
    if r := recover(); r != nil {
        logger.Error("watch seeding panic",
            "operation", "watch_seeding",
            "transfer_id", t.ID,
            "panic", r,
            "stack", string(debug.Stack()))
        // No restart for per-transfer watch - let transfer be picked up again on next cycle
    }
}()
```

2. Move ticker creation after panic recovery, add defer:
```go
ticker := time.NewTicker(pollingInterval)
defer ticker.Stop()
```

3. In ctx.Done case, add structured exit logging:
```go
case <-ctx.Done():
    logger.Info("watch seeding shutdown",
        "operation", "watch_seeding",
        "transfer_id", t.ID,
        "reason", "context_cancelled")
    return
```

4. In the ticker case when !t.IsSeeding(), REMOVE the `ticker.Stop()` call, log completion, and return cleanly:
```go
if !t.IsSeeding() {
    logger.Info("transfer stopped seeding",
        "operation", "watch_seeding",
        "transfer_id", t.ID,
        "reason", "seeding_complete")

    // ... existing hash/removal logic ...

    return  // Changed from break to return - defer will stop ticker
}
```

Note: Keep the existing hash computation and RemoveTransfers logic, just change the exit.
  </action>
  <verify>
Run `go build ./...` to check compilation.
Grep: `grep -n "defer ticker.Stop()" internal/downloader/downloader.go` returns 2 lines (one for each method).
Grep: `grep -c "ticker.Stop()" internal/downloader/downloader.go` returns exactly 2 (the defer lines only).
  </verify>
  <done>
- WatchForSeeding has `defer ticker.Stop()` immediately after ticker creation
- WatchForSeeding has deferred panic recovery with stack trace logging
- ctx.Done case logs structured exit with transfer_id
- Seeding completion case uses return (not break) so defer executes
- No inline `ticker.Stop()` calls remain in WatchForSeeding
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. `go build ./...` passes
2. `go vet ./...` passes
3. `grep -c "defer ticker.Stop()" internal/downloader/downloader.go` returns 2
4. `grep -c "recover()" internal/downloader/downloader.go` returns 2
5. No inline ticker.Stop() calls remain (only defer lines)
6. Both methods have structured exit logging
</verification>

<success_criteria>
- WatchForImported uses defer for ticker cleanup on all exit paths
- WatchForSeeding uses defer for ticker cleanup on all exit paths
- Both methods have panic recovery with stack trace logging
- Exit logging uses structured fields (operation, transfer_id, reason)
- Requirement RES-03 is satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-resource-leak-prevention/02-02-SUMMARY.md`
</output>
