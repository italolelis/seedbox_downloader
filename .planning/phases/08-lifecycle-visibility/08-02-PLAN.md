---
phase: 08-lifecycle-visibility
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - cmd/seedbox_downloader/main.go
autonomous: true

must_haves:
  truths:
    - "Shutdown logs show graceful cleanup in reverse order: server -> services -> database -> telemetry"
    - "Each shutdown phase logs 'stopping X' at start and 'X stopped' at completion"
    - "Component initialization failures log at ERROR with component name and specific error"
    - "Final 'graceful shutdown complete' message confirms clean exit"
  artifacts:
    - path: "cmd/seedbox_downloader/main.go"
      provides: "Shutdown sequence logging and error context enhancement"
      contains: "graceful shutdown complete"
  key_links:
    - from: "runMainLoop() shutdown section"
      to: "servers.api.Shutdown, services.Close, tel.Shutdown"
      via: "phase logging before/after each shutdown call"
      pattern: 'logger\.InfoContext\(shutdownCtx, "stopping'
---

<objective>
Add comprehensive shutdown and error logging to main.go

Purpose: Operators need visibility into shutdown progress and initialization failures. Clear shutdown logging helps diagnose hung shutdowns, and detailed error context helps identify which component failed and why.

Output: main.go with phased shutdown logging in reverse order, component-specific error messages for initialization failures, and timeout handling.
</objective>

<execution_context>
@/Users/italovietro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/italovietro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-lifecycle-visibility/08-RESEARCH.md
@.planning/phases/08-lifecycle-visibility/08-01-SUMMARY.md
@cmd/seedbox_downloader/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add phased shutdown logging</name>
  <files>cmd/seedbox_downloader/main.go</files>
  <action>
Update runMainLoop() shutdown section to add detailed phase logging:

1. After "start shutdown" log (or replace it), log with timeout info:
   ```go
   logger.InfoContext(shutdownCtx, "starting graceful shutdown",
       "shutdown_timeout", cfg.Web.ShutdownTimeout.String())
   ```

2. Add phase logging around each shutdown step (reverse order of startup):

   Phase 1 - Stop HTTP Server:
   ```go
   logger.InfoContext(shutdownCtx, "stopping HTTP server")
   // ... existing shutdown logic ...
   logger.InfoContext(shutdownCtx, "HTTP server stopped")
   ```

   Phase 2 - Note: services.Close() is called via defer, so shutdown logging for services
   happens implicitly. However, the defer runs AFTER runMainLoop returns, so we can't
   log from within runMainLoop. Instead, enhance services.Close() to log its own shutdown:

   In services.Close() method, add logging:
   ```go
   func (s *services) Close() {
       // Get logger from context if available, or use default
       logger := slog.Default().WithGroup("shutdown")

       logger.Info("stopping services")
       logger.Info("stopping downloader")
       s.downloader.Close()
       logger.Info("downloader stopped")

       logger.Info("stopping transfer orchestrator")
       s.transferOrchestrator.Close()
       logger.Info("transfer orchestrator stopped")

       logger.Info("services stopped")
   }
   ```

   Note: services.Close() cannot use context-aware logging because the context is cancelled
   when Close() runs via defer. Use regular Info() with the "shutdown" group.

3. Before returning from runMainLoop (after ctx.Err()), add final message:
   ```go
   logger.InfoContext(shutdownCtx, "graceful shutdown complete")
   return ctx.Err()
   ```

4. For telemetry shutdown (in run() defer), the current code silently calls tel.Shutdown(ctx).
   Unfortunately defer'd telemetry shutdown uses cancelled context. The research notes this
   is acceptable - telemetry shutdown typically has its own internal timeout.

   The research recommends: If you want telemetry shutdown logging, it would need to be
   moved from defer to explicit shutdown in runMainLoop, but that's a larger refactor.
   For now, leave telemetry defer as-is and note this as a known limitation.

Keep the existing error handling for shutdown failures - the current ErrorContext calls
are already appropriate for failed shutdowns.
  </action>
  <verify>
Run `go build ./cmd/seedbox_downloader` to verify no syntax errors.
Run `grep -n "stopping\|stopped\|graceful shutdown" cmd/seedbox_downloader/main.go` to verify shutdown logging exists.
  </verify>
  <done>
Shutdown logs show phased cleanup: starting graceful shutdown -> stopping HTTP server -> HTTP server stopped -> services stopped (via Close method) -> graceful shutdown complete.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance initialization error logging with component context</name>
  <files>cmd/seedbox_downloader/main.go</files>
  <action>
Update initialization functions to log errors with full component context at ERROR level:

1. In initializeTelemetry(), add error logging before returning error:
   ```go
   if err != nil {
       logger := logctx.LoggerFromContext(ctx)
       logger.ErrorContext(ctx, "telemetry initialization failed",
           "component", "telemetry",
           "service_name", cfg.Telemetry.ServiceName,
           "otel_address", cfg.Telemetry.OTELAddress,
           "err", err)
       return nil, fmt.Errorf("failed to initialize telemetry: %w", err)
   }
   ```

2. In initializeServices(), add error logging at each failure point:

   Database init failure:
   ```go
   if err != nil {
       logger := logctx.LoggerFromContext(ctx)
       logger.ErrorContext(ctx, "database initialization failed",
           "component", "database",
           "db_path", cfg.DBPath,
           "max_open_conns", cfg.DBMaxOpenConns,
           "max_idle_conns", cfg.DBMaxIdleConns,
           "err", err)
       return nil, fmt.Errorf("failed to initialize the database: %w", err)
   }
   ```

   Download client build failure:
   ```go
   if err != nil {
       logger := logctx.LoggerFromContext(ctx)
       logger.ErrorContext(ctx, "download client build failed",
           "component", "download_client",
           "client_type", cfg.DownloadClient,
           "err", err)
       return nil, fmt.Errorf("failed to build download client: %w", err)
   }
   ```

   Download client auth failure:
   ```go
   if err != nil {
       logger := logctx.LoggerFromContext(ctx)
       logger.ErrorContext(ctx, "download client authentication failed",
           "component", "download_client",
           "client_type", cfg.DownloadClient,
           "err", err)
       return nil, fmt.Errorf("failed to authenticate with the download client: %w", err)
   }
   ```

3. In startServers(), add error logging:
   ```go
   if err != nil {
       logger.ErrorContext(ctx, "server setup failed",
           "component", "http_server",
           "bind_address", cfg.Web.BindAddress,
           "err", err)
       return nil, fmt.Errorf("failed to setup server: %w", err)
   }
   ```

4. In setupServer() for the putio client check:
   ```go
   if _, ok := originalClient.(*putio.Client); !ok {
       logger := logctx.LoggerFromContext(ctx)
       logger.ErrorContext(ctx, "invalid download client type",
           "component", "http_server",
           "expected", "putio",
           "actual", cfg.DownloadClient,
           "err", "download client is not a putio client")
       return nil, fmt.Errorf("download client is not a putio client: %s", cfg.DownloadClient)
   }
   ```

Each error log MUST include:
- "component" field identifying which component failed
- Relevant configuration that might explain the failure (paths, addresses, types)
- "err" field with the actual error
- Do NOT log secrets even in error messages
  </action>
  <verify>
Run `go build ./cmd/seedbox_downloader` to verify no syntax errors.
Run `go vet ./cmd/seedbox_downloader` to verify no issues.
Run `grep -n 'ErrorContext.*component' cmd/seedbox_downloader/main.go` to verify component field in error logs.
  </verify>
  <done>
All initialization failures log at ERROR with component name, relevant config context, and specific error. Component failures are immediately identifiable from logs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify shutdown and error logging</name>
  <files>cmd/seedbox_downloader/main.go</files>
  <action>
Verify the shutdown and error logging implementation:

1. Run `go vet ./cmd/seedbox_downloader` to verify no issues with logging calls.

2. Run `go test ./...` to ensure no regressions.

3. Verify shutdown logging order by reading runMainLoop:
   - "starting graceful shutdown" with timeout
   - "stopping HTTP server"
   - "HTTP server stopped"
   - (services.Close() logs its own shutdown via defer after return)
   - "graceful shutdown complete"

4. Verify error logging has component context:
   - initializeTelemetry error includes component=telemetry
   - initializeServices database error includes component=database
   - initializeServices client errors include component=download_client
   - startServers error includes component=http_server

No code changes in this task - verification only.
  </action>
  <verify>
`go vet ./cmd/seedbox_downloader` passes.
`go test ./...` passes.
Manual inspection confirms shutdown logging order and error component context.
  </verify>
  <done>
Shutdown logging verified in reverse order. Error logging verified with component context. All tests pass.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./cmd/seedbox_downloader` compiles successfully
2. `go vet ./cmd/seedbox_downloader` passes
3. `go test ./...` passes
4. Grep confirms shutdown logging: `grep -c "stopping\|stopped\|graceful shutdown" cmd/seedbox_downloader/main.go` shows multiple matches
5. Grep confirms component error context: `grep -c 'ErrorContext.*component' cmd/seedbox_downloader/main.go` shows matches for each init function
</verification>

<success_criteria>
1. Shutdown logs show graceful cleanup sequence (LIFECYCLE-04)
2. Component initialization failures log at ERROR with specific failure reason (LIFECYCLE-05)
3. Component name included in all error logs for quick identification
4. Shutdown timeout logged to help diagnose slow shutdowns
5. All tests pass, code compiles and vets cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/08-lifecycle-visibility/08-02-SUMMARY.md`
</output>
