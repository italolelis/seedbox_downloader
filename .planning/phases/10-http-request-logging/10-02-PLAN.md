---
phase: 10-http-request-logging
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - cmd/seedbox_downloader/main.go
autonomous: true

must_haves:
  truths:
    - "All HTTP requests log method, path, and status code"
    - "HTTP requests include auto-generated request_id in logs"
    - "HTTP error responses (5xx) log at ERROR level"
    - "HTTP client errors (4xx) log at WARN level"
    - "HTTP success responses (2xx) log at INFO level"
    - "HTTP request logs include duration_ms for performance tracking"
  artifacts:
    - path: "cmd/seedbox_downloader/main.go"
      provides: "HTTP server with logging middleware chain"
      contains: "telemetry.RequestID"
  key_links:
    - from: "cmd/seedbox_downloader/main.go"
      to: "internal/telemetry/request_id.go"
      via: "r.Use(telemetry.RequestID)"
      pattern: "r\\.Use\\(telemetry\\.RequestID\\)"
    - from: "cmd/seedbox_downloader/main.go"
      to: "internal/telemetry/http_logging.go"
      via: "r.Use(telemetry.HTTPLogging)"
      pattern: "r\\.Use\\(telemetry\\.HTTPLogging\\)"
---

<objective>
Integrate HTTP logging middleware into Chi router with correct ordering.

Purpose: Enable HTTP request logging for all API endpoints with trace correlation.
Output: Working HTTP logging visible in application logs with proper log levels.
</objective>

<execution_context>
@/Users/italovietro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/italovietro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-http-request-logging/10-RESEARCH.md
@.planning/phases/10-http-request-logging/10-01-SUMMARY.md

# Current server setup
@cmd/seedbox_downloader/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate middleware in setupServer</name>
  <files>cmd/seedbox_downloader/main.go</files>
  <action>
Update setupServer function in cmd/seedbox_downloader/main.go:

1. Add middleware in correct order after `r := chi.NewRouter()`:
   ```go
   // Middleware order is critical:
   // 1. RequestID - generates request_id, stores in context
   r.Use(telemetry.RequestID)

   // 2. otelhttp - creates span, adds trace context to r.Context()
   r.Use(telemetry.NewHTTPMiddleware(cfg.Telemetry.ServiceName))

   // 3. HTTPLogging - logs after handler completes with request_id, trace_id, span_id
   r.Use(telemetry.HTTPLogging)
   ```

2. The existing `r.Use(telemetry.NewHTTPMiddleware(...))` line needs to be moved to position 2.

3. No changes to imports needed - telemetry package already imported.

Middleware order rationale (from 10-RESEARCH.md):
- RequestID runs first to generate request_id before other middleware
- otelhttp runs second to create span with trace context
- HTTPLogging runs last to have access to request_id and trace context (via TraceHandler)
  </action>
  <verify>
```bash
# Application compiles
go build ./cmd/seedbox_downloader/...

# Quick integration test - start server briefly and make request
# (Manual verification: start app, make curl request, check logs)
```
  </verify>
  <done>
- setupServer uses middleware in order: RequestID -> NewHTTPMiddleware -> HTTPLogging
- Application compiles and starts without errors
- HTTP requests produce structured logs with method, path, status, duration_ms, request_id
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify end-to-end logging</name>
  <files>cmd/seedbox_downloader/main.go</files>
  <action>
Run the application briefly to verify HTTP logging works end-to-end:

1. Start the application (it will fail without full config, but we can test compilation):
   ```bash
   go build -o /tmp/seedbox_test ./cmd/seedbox_downloader/...
   ```

2. Verify the middleware chain is correct by code inspection:
   - RequestID is first r.Use call
   - NewHTTPMiddleware is second r.Use call
   - HTTPLogging is third r.Use call

3. Document expected log output format:
   ```json
   {
     "time": "...",
     "level": "INFO",
     "msg": "http request completed",
     "method": "POST",
     "path": "/transmission/rpc",
     "status": 200,
     "duration_ms": 45,
     "request_id": "550e8400-e29b-41d4-a716-446655440000",
     "trace_id": "...",
     "span_id": "..."
   }
   ```

No additional code changes - this task validates the integration from Task 1.
  </action>
  <verify>
```bash
# Full test suite passes
go test ./...

# Binary builds successfully
go build -o /tmp/seedbox_test ./cmd/seedbox_downloader/...
```
  </verify>
  <done>
- All existing tests pass (no regressions)
- Binary builds successfully with new middleware
- HTTP logging requirements verified:
  - HTTP-01: method, path, status logged
  - HTTP-02: request_id in logs
  - HTTP-03: 5xx at ERROR
  - HTTP-04: 4xx at WARN
  - HTTP-05: 2xx at INFO
  - HTTP-06: duration_ms included
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass
go test ./...

# Binary builds
go build ./cmd/seedbox_downloader/...

# Verify middleware order in code
grep -A 10 "chi.NewRouter" cmd/seedbox_downloader/main.go | grep -E "r\.Use"
```
</verification>

<success_criteria>
- All tests pass (go test ./...)
- Application compiles without errors
- Middleware chain order: RequestID -> NewHTTPMiddleware -> HTTPLogging
- HTTP request logging produces JSON with: method, path, status, duration_ms, request_id
- Log levels vary by status code (INFO/WARN/ERROR)
</success_criteria>

<output>
After completion, create `.planning/phases/10-http-request-logging/10-02-SUMMARY.md`
</output>
