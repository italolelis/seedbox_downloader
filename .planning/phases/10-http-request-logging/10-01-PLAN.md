---
phase: 10-http-request-logging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/telemetry/request_id.go
  - internal/telemetry/http_logging.go
autonomous: true

must_haves:
  truths:
    - "RequestID middleware generates UUID v4 for each request"
    - "RequestID middleware propagates existing X-Request-ID header"
    - "RequestID middleware sets X-Request-ID response header"
    - "HTTPLogging middleware captures status code from response"
    - "HTTPLogging middleware logs at appropriate level based on status"
  artifacts:
    - path: "internal/telemetry/request_id.go"
      provides: "RequestID middleware and GetRequestID helper"
      exports: ["RequestID", "GetRequestID"]
      contains: "uuid.New"
    - path: "internal/telemetry/http_logging.go"
      provides: "HTTPLogging middleware and response writer wrapper"
      exports: ["HTTPLogging"]
      contains: "wrapResponseWriter"
  key_links:
    - from: "internal/telemetry/request_id.go"
      to: "context.WithValue"
      via: "stores request_id in context"
      pattern: "context\\.WithValue.*requestIDKey"
    - from: "internal/telemetry/http_logging.go"
      to: "internal/logctx"
      via: "retrieves logger from context"
      pattern: "logctx\\.LoggerFromContext"
---

<objective>
Create HTTP request logging middleware components for Chi router.

Purpose: Enable structured logging of all HTTP requests with request correlation IDs and status-based log levels.
Output: Two new middleware files in internal/telemetry that can be used with Chi router.
</objective>

<execution_context>
@/Users/italovietro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/italovietro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-http-request-logging/10-RESEARCH.md

# Existing telemetry patterns
@internal/telemetry/middleware.go
@internal/logctx/logctx.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RequestID middleware</name>
  <files>internal/telemetry/request_id.go</files>
  <action>
Create RequestID middleware in internal/telemetry/request_id.go:

1. Define context key type and constants:
   - `type ctxKey string`
   - `const requestIDKey ctxKey = "request_id"`
   - `const RequestIDHeader = "X-Request-ID"`

2. Create RequestID middleware function:
   - Check incoming X-Request-ID header (propagation from upstream)
   - If empty, generate UUID v4 using `github.com/google/uuid`
   - Set X-Request-ID response header
   - Store request_id in context using context.WithValue
   - Call next.ServeHTTP with updated request context

3. Create GetRequestID helper function:
   - Extract request_id from context
   - Return empty string if not found (defensive)

Follow the pattern from 10-RESEARCH.md Pattern 2 exactly. Import google/uuid which is already in go.mod.
  </action>
  <verify>
File exists and compiles:
```bash
go build ./internal/telemetry/...
```
  </verify>
  <done>
- request_id.go exports RequestID middleware and GetRequestID helper
- UUID v4 generated when no X-Request-ID header present
- X-Request-ID header set on response
- request_id stored in context and retrievable via GetRequestID
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HTTPLogging middleware with response writer wrapper</name>
  <files>internal/telemetry/http_logging.go</files>
  <action>
Create HTTPLogging middleware in internal/telemetry/http_logging.go:

1. Create responseWriter wrapper struct:
   - Embed http.ResponseWriter
   - Add `status int` field (default 200)
   - Add `wroteHeader bool` flag
   - Implement WriteHeader to capture status code and set flag
   - Implement Write to set implicit 200 OK if WriteHeader not called

2. Create wrapResponseWriter factory function:
   - Returns pointer to responseWriter with status defaulted to http.StatusOK

3. Create HTTPLogging middleware function:
   - Get logger from context via logctx.LoggerFromContext
   - Record start time
   - Wrap response writer
   - Call next.ServeHTTP with wrapped writer
   - After handler completes, calculate duration_ms
   - Get request_id from context via GetRequestID
   - Build log attributes: method, path, status, duration_ms, request_id
   - Log at appropriate level based on status code:
     - status >= 500: logger.ErrorContext (HTTP-03)
     - status >= 400: logger.WarnContext (HTTP-04)
     - status < 400: logger.InfoContext (HTTP-05)
   - Message: "http request completed"

Follow the patterns from 10-RESEARCH.md Patterns 1 and 3. Import logctx package for logger retrieval.
  </action>
  <verify>
File exists and compiles:
```bash
go build ./internal/telemetry/...
```
  </verify>
  <done>
- http_logging.go exports HTTPLogging middleware
- Response writer wrapper captures status code including implicit 200 OK
- Logs include method, path, status, duration_ms, request_id fields (HTTP-01, HTTP-02, HTTP-06)
- Log level varies by status: ERROR for 5xx, WARN for 4xx, INFO for 2xx (HTTP-03, HTTP-04, HTTP-05)
  </done>
</task>

</tasks>

<verification>
```bash
# Both files compile
go build ./internal/telemetry/...

# Package exports are correct
go doc ./internal/telemetry | grep -E "RequestID|HTTPLogging|GetRequestID"
```
</verification>

<success_criteria>
- internal/telemetry/request_id.go exists with RequestID and GetRequestID exports
- internal/telemetry/http_logging.go exists with HTTPLogging export
- Both files compile without errors
- Middleware signatures match Chi middleware pattern: `func(http.Handler) http.Handler`
</success_criteria>

<output>
After completion, create `.planning/phases/10-http-request-logging/10-01-SUMMARY.md`
</output>
